n = int(input())
dp = [0] * (n + 1)

for i in range(2, n+1):
    dp[i] = dp[i-1] + 1
    
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2] + 1)

    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1)
    
print(dp[n])

"""
이 문제는 1로 만들기 위해 필요한 최소 연산 횟수를 구하는 문제
최저 문제이기에 탐색 or 최적화 문제 -> 그리디 or DP 문제

먼저 그리디 방식을 적용해봄. 가장 숫자를 줄일 수 있는 3 나누기나 2 나누기를 먼저 적용해봄
-> 10일 경우 반례가 생김 -> DP 적용

DP 방식으로 풀기 위해서는 점화식을 세워야 함
총 3가지의 경우 -1, /2, /3이 있음
dp[i]를 구하기 위해서는 i보다 작은 dp의 값들을 활용해야 함.
i에 도달하기 직전의 dp의 값은 dp[i-1], dp[i/2], dp[i/3] 를 통해서 알수 있음. 해당 값들 중에서 가장 작은 값을 택하면 됨

초기 값부터 차례대로 채워나가면 됨
"""