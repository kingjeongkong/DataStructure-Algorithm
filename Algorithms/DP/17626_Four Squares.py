import math

n = int(input())

num_list = [0] * (n+1)
num_list[1] = 1

for i in range(2, n+1):
    sqrt_int = math.isqrt(i)
    
    if sqrt_int ** 2 == i:
        num_list[i] = 1
    else:
        sub_list = []
        for k in range(1, sqrt_int + 1):
            sub_list.append(num_list[i - k**2])
        num_list[i] = 1 + min(sub_list)

print(num_list[n])


"""
해당 문제는 제곱수들의 최소 개수를 찾는 문제
최소를 찾는 문제이기에 BFS, DP, 그리디를 떠올릴 수 있음
인접한 것들을 찾는게 아니기에 BFS는 아니고, 각 순간에 최적의 선택을 한다도 아닌거 같으므로 그리디도 아님
1-25까지 직접 제곱수들의 합으로 구해보니 이전의 값들을 재사용해서 풀 수 있기에 DP로 접근

처음의 접근은 특정 수의 제곱근의 정수부분만 추출하여 해당 수에서 제곱근의 정수부분의 제곱근을 빼고 나머지의 수는 메모이제이션 해놓은 값을 기반으로 더해서 구하려고 했지만, 반례가 생겼음(e.g. 12 = 4 + 4 + 4 , 23 = 9+9+4+1)
23의 경우를 보고 제곱근의 정수부분에서 1만 빼고 다시 제곱을 해서 수에서 빼고 계산하면 될 줄 알았는데 모든 경우는 커버하지 못하는거 같음.
따라서 제곱근의 정수부분을 1~sqrt_int까지 하나씩 빼가면서 이중에서 최저 개수의 제곱수들의 합의 값을 찾아내면 됨
"""