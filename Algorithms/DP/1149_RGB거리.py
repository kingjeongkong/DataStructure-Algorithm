import sys

n = int(sys.stdin.readline())
price = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]
dp = [[0]*3 for _ in range(n)]

dp[0][0] = price[0][0]
dp[0][1] = price[0][1]
dp[0][2] = price[0][2]

for i in range(1, n):
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + price[i][0]
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + price[i][1]
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + price[i][2]

print(min(dp[n-1]))

"""
해당 문제는 각 집을 색칠하는데 인접한 집의 색과 겹치면 안되는 문제
최소 비용을 구하는 문제이기에 BFS, DP, 그리디를 떠올릴 수 있음
BFS는 해당 문제에 적합하지 않고, 입력값 N이 1000이기에 브루트포스를 떠올려 봄 -> 시간복잡도가 3*2^999이므로 불가능
따라서 그리디로 풀어봄 -> 각 선택에서 인접한 집의 색을 제외하고 최소 비용을 찾아서 풀어봄 -> 반례가 생김.

이전의 선택이 이후의 선택에도 영향을 미치고, 앞의 선택들(이전 집들의 색을 칠한 비용들)을 재사용할 수 있다는 생각도 들었지만, 그동안 풀어왔던 DP 문제들은 모두 이전의 선택에 대한 메모이제이션이 1차원 리스트였음(한가지의 선택지만 고려하면 됐음). 하지만 이 문제는 메모이제이션을 2차원으로 만들어서 3가지의 선택에 대해 모두 고려하고 저장해둬야 했음.

따라서 dp를 2차원 배열로 만든 후, RGB 각 모든 색상을 선택했을 때에 대한 값을 메모이제이션 해주면 됨
"""