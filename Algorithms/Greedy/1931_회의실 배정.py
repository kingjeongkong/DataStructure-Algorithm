import sys

n = int(sys.stdin.readline().strip())
time_list = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]
time_list.sort(key=lambda x: (x[1], x[0]))
last_end_time = 0
answer = 0

for time in time_list:
    start, end = time
    
    if start >= last_end_time:
        last_end_time = end
        answer += 1

print(answer)

"""
해당 문제는 사용할 수 있는 회의의 최대의 개수를 구하는 문제
최적의 해를 구해야 함. => 그리디 알고리즘을 떠올릴 수 있음

그리디 알고리즘 문제를 푸는 방법
목표를 확인하고 해당 목표를 구하기 위해 어떤 선택을 해야 하는지 나열해본다
여러 가지 선택의 후보들에 대해서 각각 반례를 찾아나가면서 선택을 소거법함.
이후 찾은 선택를 적용해서 풀면 됨

이 문제에서는 초반에 가장 빨리 시작하는 회의, 회의 시간이 짧은 회의 이렇게 두가지 선택을 떠올림
하지만 빨리 시작하는 회의는 [9시~18시], [10시~12시], [13시~15시] 다음과 같은 회의에서 반례가 생김
회의 시간이 짧은 회의는 [9시~14시], [15시~18시], [13시~16시]와 같은 경우에서 반례가 생김

따라서 가장 빨리 끝나는 회의를 선택하는 기준을 생각할 수 있음.
입력값인 N이 100,000이하이므로 반복문을 여러번 사용하면 시간 초과가 날 수 있음.
최소한의 반복문으로 풀기 위해 회의가 빨리 끝나는 순서로 정렬하고, [7~9] [9~9]와 같은 경우에 대비해서 끝나는 시간이 같으면 빨리 시작하는 순서로 정렬함(lambda 활용).
이후 구해주면 됨
"""